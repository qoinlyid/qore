package templates

import (
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/qoinlyid/qore"
)

const moduleLoaderFile = "module_loader_gen.go"

const modLoaderTmpl = `// Code generated by github.com/qoinlyid/qore; DO NOT EDIT.
// Code generated by github.com/qoinlyid/qore; DO NOT EDIT.
// Code generated by github.com/qoinlyid/qore; DO NOT EDIT.
package main

import (
{{- range .AvailableModules }}
	"{{$.ProjectPackage}}/{{$.ModuleDir}}/{{.}}"
{{- end }}
{{- if .Pkg}}
	"{{.ProjectPackage}}/{{.ModuleDir}}/{{.Pkg}}"
{{- end}}

	"github.com/qoinlyid/qore"
)

// Code generated by github.com/qoinlyid/qore; DO NOT EDIT.
// moduleLoaderImpl implements ` + "`qore#ModuleLoader`" + `.
type moduleLoaderImpl struct{ modules []qore.Module }

// Code generated by github.com/qoinlyid/qore; DO NOT EDIT.
// Compile time check moduleLoaderImpl Instance implements ` + "`qore#ModuleLoader`" + `.
var _ qore.ModuleLoader = (*moduleLoaderImpl)(nil)

// Code generated by github.com/qoinlyid/qore; DO NOT EDIT.
// Load returns slice of ` + "`qore#Module`" + `.
func (loader *moduleLoaderImpl) Load() []qore.Module { return loader.modules }

// Code generated by github.com/qoinlyid/qore; DO NOT EDIT.
// moduleLoader set the modules to be loaded.
var moduleLoader *moduleLoaderImpl = &moduleLoaderImpl{
	modules: []qore.Module{
	{{- range .AvailableModules }}
		{{.}}.InitModule(),
	{{- end }}
	{{- if .Name}}
		{{.Name}}.InitModule(),
	{{- end}}
	},
}
`

// Code templates.
var moduleGenerateds map[string]string = map[string]string{
	"_gen.go": `// Code generated by github.com/qoinlyid/qore; DO NOT EDIT.
// Code generated by github.com/qoinlyid/qore; DO NOT EDIT.
// Code generated by github.com/qoinlyid/qore; DO NOT EDIT.
package {{.Name}}

{{- if .Dependencies }}

import (
{{- range .Dependencies }}
	"{{ .Path }}"
{{- end }}
)

{{- end }}

// Code generated by github.com/qoinlyid/qore; DO NOT EDIT.
// Module defines {{.Struct}} module.
type Module struct {
{{- if .Dependencies }}
	// Used dependencies.
{{- range $name, $dep := .Dependencies }}
	{{ $name }} *{{ $name }}.Instance
{{- end }}
{{- end }}

	svc *Service
}

// Code generated by github.com/qoinlyid/qore; DO NOT EDIT.
// InitModule returns {{.Struct}} module instance.
func InitModule() *Module {
	m := &Module{
{{- if .Dependencies }}
		// Init dependencies.
{{- range $name, $dep := .Dependencies }}
		{{ $name }}: {{ $name }}.New(),
{{- end }}
{{- end }}
	}
	m.setService()
{{- if .MakePublic }}
	initPublic(m)
{{- end }}

	return m
}
`,
	"_public_gen.go": `// Code generated by github.com/qoinlyid/qore; DO NOT EDIT.
// Code generated by github.com/qoinlyid/qore; DO NOT EDIT.
// Code generated by github.com/qoinlyid/qore; DO NOT EDIT.
package {{.Name}}

// Code generated by github.com/qoinlyid/qore; DO NOT EDIT.
var mod *Module

// Code generated by github.com/qoinlyid/qore; DO NOT EDIT.
// initPublic will set the module variable.
func initPublic(m *Module) { mod = m }

// Code generated by github.com/qoinlyid/qore; DO NOT EDIT.
// Public returns pointer of module instance, be careful it's may be nil.
func Public() *Module { return mod }
`,
	"_service.go": `package {{.Name}}

func (m *Module) setService() {
	m.svc = &Service{repo: newRepoMock()}
}
`,
	"entity.go":        `package {{.Name}}`,
	"http_dto.go":      `package {{.Name}}`,
	"http_handlers.go": `package {{.Name}}`,
	"http_routes.go": `package {{.Name}}

import (
	"github.com/qoinlyid/qore"
)

// HttpRoutes will set module's HTTP(s) route into the ` + "`qore#App`" + `.
func (m *Module) HttpRoutes(app *qore.App) {}
`,
	"repo_mock.go": `package {{.Name}}

type repoMock struct{}

// Compile time check ` + "`repoMock`" + ` implements ` + "`Repository`" + `.
var _ Repository = (*repoMock)(nil)

// newRepoMock returns repo mock.
func newRepoMock() Repository { return &repoMock{} }
`,
	"repo.go": `package {{.Name}}

// Repository defines interface for data access.
type Repository interface{}
`,
	"service_test.go": `package {{.Name}}

func newServiceTest() *Service {
	return &Service{repo: newRepoMock()}
}
`,
	"service.go": `package {{.Name}}

// Service defines business logic use-case.
type Service struct {
	repo Repository
}
`,
}

// Module defines auto-generated module code data.
type Module struct {
	// Module.
	Name       string
	Struct     string
	Pkg        string
	Dir        string
	MakePublic bool
	// Project.
	RootProjectDir   string
	ProjectPackage   string
	ModuleDir        string
	AvailableModules []string
	Dependencies     Dependencies
}

func getModules(dir string) ([]string, error) {
	entries, err := os.ReadDir(dir)
	if err != nil {
		return nil, fmt.Errorf("failed to read directories inside module dir: %w", err)
	}
	var mods []string
	for _, entry := range entries {
		if entry.IsDir() {
			mods = append(mods, entry.Name())
		}
	}
	return mods, nil
}

// NewModule creates and generate new qore app module.
func NewModule(module *Module) error {
	// Read all available module inside module dir of the project.
	projectModuleDir := filepath.Join(module.RootProjectDir, module.ModuleDir)
	mods, err := getModules(projectModuleDir)
	if err != nil {
		return err
	}
	module.AvailableModules = mods

	// Create or re-write module loader file.
	fpathModLoader := filepath.Join(module.RootProjectDir, moduleLoaderFile)
	fileModLoader, err := os.Create(fpathModLoader)
	if err != nil {
		return fmt.Errorf("failed to create file %s: %w", moduleLoaderFile, err)
	}
	defer fileModLoader.Close()
	tmplModLoader, err := template.New("code").Parse(modLoaderTmpl)
	if err != nil {
		return fmt.Errorf("failed to parse module loader generated template: %w", err)
	}
	if err := tmplModLoader.Execute(fileModLoader, module); err != nil {
		return fmt.Errorf("failed to write module loader code: %w", err)
	}

	// Create module directory.
	if err := os.MkdirAll(module.Dir, 0755); err != nil {
		return fmt.Errorf("failed to create module directory: %w", err)
	}

	// Generate code.
	var errs []error
	for name, code := range moduleGenerateds {
		if !module.MakePublic && name == "_public_gen.go" {
			continue
		}

		// File path.
		fname := name
		if strings.HasPrefix(fname, "_") {
			fname = module.Name + fname
		}
		fpath := filepath.Join(module.Dir, fname)

		// Parse code template.
		tmpl, err := template.New("code").Parse(code)
		if err != nil {
			errs = append(errs, fmt.Errorf("failed to parse code %s: %w", fname, err))
			continue
		}

		// Create file.
		f, err := os.Create(fpath)
		if err != nil {
			errs = append(errs, fmt.Errorf("failed to create file %s: %w", fpath, err))
			continue
		}
		defer f.Close()

		// Write code into file.
		if err := tmpl.Execute(f, module); err != nil {
			errs = append(errs, fmt.Errorf("failed to write code into file %s: %w", fpath, err))
		}
	}
	err = errors.Join(errs...)
	return err
}

// RemoveModule deletes existing module(s) based on given removes parameter.
func RemoveModule(module *Module, removes []string) error {
	projectModuleDir := filepath.Join(module.RootProjectDir, module.ModuleDir)
	mods, err := getModules(projectModuleDir)
	if err != nil {
		return err
	}
	module.AvailableModules = qore.SliceRemoveItems(mods, removes)

	// Create or re-write module loader file.
	fpathModLoader := filepath.Join(module.RootProjectDir, moduleLoaderFile)
	fileModLoader, err := os.Create(fpathModLoader)
	if err != nil {
		return fmt.Errorf("failed to create file %s: %w", moduleLoaderFile, err)
	}
	defer fileModLoader.Close()
	tmplModLoader, err := template.New("code").Parse(modLoaderTmpl)
	if err != nil {
		return fmt.Errorf("failed to parse module loader generated template: %w", err)
	}
	if err := tmplModLoader.Execute(fileModLoader, module); err != nil {
		return fmt.Errorf("failed to write module loader code: %w", err)
	}

	// Remove module directory.
	var errs []error
	for _, rm := range removes {
		mdir := filepath.Join(projectModuleDir, rm)
		if err := os.RemoveAll(mdir); err != nil {
			errs = append(errs, err)
		}
	}
	return errors.Join(errs...)
}
