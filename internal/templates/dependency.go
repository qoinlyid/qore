package templates

const (
	depGenTmpl string = `
// Code generated by github.com/qoinlyid/qore; DO NOT EDIT.
// Code generated by github.com/qoinlyid/qore; DO NOT EDIT.
// Code generated by github.com/qoinlyid/qore; DO NOT EDIT.
package {{ .PkgName }}

import "github.com/qoinlyid/qore"

// Code generated by github.com/qoinlyid/qore; DO NOT EDIT.
// instanceGen defines {{ .DepName }} dependency singleton.
type instanceGen struct {
	// Priority of open-close dependency.
	priority int
}

// Code generated by github.com/qoinlyid/qore; DO NOT EDIT.
// Compile time check {{ .DepName }} Instance implements qore.Dependency.
var _ qore.Dependency = (*Instance)(nil)

// Code generated by github.com/qoinlyid/qore; DO NOT EDIT.
// Name returns dependency name.
func (i *Instance) Name() string { return "{{ .DepName }}" }

// Code generated by github.com/qoinlyid/qore; DO NOT EDIT.
// Priority returns dependency open-close priority.
func (i *Instance) Priority() int { return i.instanceGen.priority }
`

	depCfgTmpl string = `
package {{ .PkgName }}

import (
	"errors"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/joho/godotenv"
	"github.com/qoinlyid/qore"
	"github.com/spf13/viper"
)

// Config defines {{ .DepName }} config.
type Config struct {
	{{ .DepName }}Priority int ` + "`json:\"{{ .StructTag }}_PRIORITY\" mapstructure:\"{{ .StructTag }}_PRIORITY\"`" + `
}

// Default config.
var defaultConfig = &Config{
	{{ .DepName }}Priority:   10,
}

// Load config.
func loadConfig() *Config {
	var e error
	config := defaultConfig

	// Get used config from OS env.
	configSource := os.Getenv(qore.CONFIG_USED_KEY)
	if qore.ValidationIsEmpty(configSource) {
		configSource = "OS"
	}
	viper.AutomaticEnv()
	viper.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))

	switch strings.ToUpper(configSource) {
	case "OS":
		if err := viper.Unmarshal(&config); err != nil {
			e = errors.Join(fmt.Errorf("failed to parse OS env value to config: %w", err))
		}
	default:
		ext := strings.ToLower(filepath.Ext(configSource))
		switch ext {
		case ".env":
			if err := godotenv.Load(configSource); err != nil {
				e = errors.Join(fmt.Errorf("failed to load .env file %s: %w", configSource, err))
			}
			if err := viper.Unmarshal(&config); err != nil {
				e = errors.Join(fmt.Errorf("failed to parse .env value to config: %w", err))
			}
		case ".json", ".yml", ".yaml", ".toml":
			viper.SetConfigFile(configSource)
			if err := viper.ReadInConfig(); err != nil {
				e = errors.Join(fmt.Errorf("failed to read config file %s: %w", configSource, err))
			} else {
				if err := viper.Unmarshal(&config); err != nil {
					e = errors.Join(fmt.Errorf("failed to parse config file %s value to config: %w", configSource, err))
				}
			}
		}
	}

	if e != nil {
		log.Printf("qore config - failed to load config: %s\n", e.Error())
	}
	return config
}`

	depTmpl string = `
package {{ .PkgName }}

// Instance defines {{ .DepName }} dependency singleton.
type Instance struct {
	// Define dependency singleton here.

	// Private field.
	cfg *Config
	*instanceGen
}

// New creates singleton dependency instance.
func New() *Instance {
	config := loadConfig()
	instance := &Instance{
		cfg:         config,
		instanceGen: &instanceGen{priority: config.{{ .DepName }}Priority},
	}
	return instance
}

// IsReady returns if the dependency is ready.
func (i *Instance) IsReady() bool {
	// Write your code here.

	// Return.
	return true
}

// Open an backend connection or construct the dependency.
func (i *Instance) Open() error {
	// Write your code here.

	// Return.
	return nil
}

// Close an backend connection or destruct the dependency.
func (i *Instance) Close() error {
	// Write your code here.

	// Return.
	return nil
}
`
)

// // Dependency defines auto-generated dependency code data.
// type Dependency struct {
// 	PkgUrl    string
// 	StructTag string
// 	DepName   string
// 	PkgName   string
// }

// Dependencies defines custom type for Qore dependencies.
type Dependencies map[string]Dependency

// Dependency defines dependency entry in manifest.
type Dependency struct {
	Version string `mapstructure:"version" toml:"version,inline"`
	Path    string `mapstructure:"path" toml:"path,inline"`
}

// MakeDependency generates Qore dependency.
// func MakeDependency(dep Dependency, fpath string) error {
// 	// File path.
// 	fpathIden := filepath.Join(fpath, fmt.Sprintf("%s.qdep", dep.DepName))
// 	fpathGen := filepath.Join(fpath, fmt.Sprintf("%s_gen.go", dep.PkgName))
// 	fpathCfg := filepath.Join(fpath, "config.go")
// 	fpathDep := filepath.Join(fpath, fmt.Sprintf("%s.go", dep.PkgName))

// 	// Parse template.
// 	tmplGen, err := template.New("code").Parse(depGenTmpl)
// 	if err != nil {
// 		return fmt.Errorf("failed to parse generated template: %w", err)
// 	}
// 	tmplCfg, err := template.New("code").Parse(depCfgTmpl)
// 	if err != nil {
// 		return fmt.Errorf("failed to parse config template: %w", err)
// 	}
// 	tmplDep, err := template.New("code").Parse(depTmpl)
// 	if err != nil {
// 		return fmt.Errorf("failed to parse dependency template: %w", err)
// 	}

// 	// Create file.
// 	fiden, err := os.Create(fpathIden)
// 	if err != nil {
// 		return fmt.Errorf("failed to create identifier file: %w", err)
// 	}
// 	defer fiden.Close()
// 	fgen, err := os.Create(fpathGen)
// 	if err != nil {
// 		return fmt.Errorf("failed to create generated file: %w", err)
// 	}
// 	defer fgen.Close()
// 	fcfg, err := os.Create(fpathCfg)
// 	if err != nil {
// 		return fmt.Errorf("failed to create config file: %w", err)
// 	}
// 	defer fcfg.Close()
// 	fdep, err := os.Create(fpathDep)
// 	if err != nil {
// 		return fmt.Errorf("failed to create dependency file: %w", err)
// 	}
// 	defer fdep.Close()

// 	// Execute.
// 	iden := dep.PkgName
// 	if len(strings.TrimSpace(dep.PkgUrl)) > 0 {
// 		iden = dep.PkgUrl + "/" + iden
// 	}
// 	if _, err := fiden.WriteString(iden); err != nil {
// 		return fmt.Errorf("failed to write identifier file: %w", err)
// 	}
// 	if err := tmplGen.Execute(fgen, dep); err != nil {
// 		return fmt.Errorf("failed to write generated file: %w", err)
// 	}
// 	if err := tmplCfg.Execute(fcfg, dep); err != nil {
// 		return fmt.Errorf("failed to write config file: %w", err)
// 	}
// 	if err := tmplDep.Execute(fdep, dep); err != nil {
// 		return fmt.Errorf("failed to write dependency file: %w", err)
// 	}
// 	return nil
// }
